# Implementation Plan: Chat UI & End-to-End Integration

**Branch**: `main` | **Date**: 2026-02-12 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `specs/Phase-III-todo-ai-chatbot/Part-C-chat-ui-integration/spec.md`

## Summary

Integrate a chat UI with the existing AI Agent (Part B) to provide an authenticated, conversational interface for todo management. Users will interact with their tasks through natural language in a modern chat interface built with OpenAI ChatKit. All conversations and messages persist to Neon PostgreSQL, maintaining the stateless server architecture where context is reconstructed per request.

**Primary Requirement**: Enable authenticated users to manage todos through a chat interface that integrates with the AI Agent from Part B.

**Technical Approach**: Build a Next.js chat page using OpenAI ChatKit components, create backend endpoints for chat and conversation history, persist all messages to PostgreSQL, and integrate with the existing AI Agent service for natural language processing.

## Technical Context

**Language/Version**: Python 3.11+ (backend), TypeScript/JavaScript (frontend with Next.js 16+)
**Primary Dependencies**:
- Backend: FastAPI, SQLModel, existing AI Agent service from Part B
- Frontend: Next.js 16+ App Router, OpenAI ChatKit, Better Auth client
**Storage**: Neon PostgreSQL (existing database, new tables for conversations and messages)
**Testing**:
- Backend: pytest, pytest-asyncio
- Frontend: Jest, React Testing Library
**Target Platform**: Web (modern browsers: Chrome 90+, Firefox 88+, Safari 14+, Edge 90+)
**Project Type**: Web application (existing monorepo with backend/ and frontend/ directories)
**Performance Goals**:
- Chat endpoint response time <3 seconds (95th percentile)
- Conversation history load <2 seconds
- Support 100 concurrent chat sessions
- Database queries <500ms
**Constraints**:
- Server must remain stateless (no session storage)
- Conversation history limited to 50 messages per retrieval
- Message length limited to 1000 characters
- Rate limiting: 10 messages per minute per user
- JWT token expiration handled by Better Auth (~1 hour)
**Scale/Scope**:
- 10k users (per constitution)
- Integration feature only - no new task management capabilities
- No changes to existing Part A (MCP) or Part B (AI Agent) APIs

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

- [x] I. Persistence & State Ownership: Neon PostgreSQL used, backend is source of truth for conversations and messages
- [x] II. Clean Architecture: Domain logic (conversation management, message persistence) in backend, UI thin (rendering only)
- [x] V. API-First & Validation: All interaction via REST API (POST /api/{user_id}/chat, GET /api/{user_id}/conversations/{id}/messages), structured error responses
- [x] VII. API-First Architecture: Clear request/response contracts defined in spec (JSON schemas for chat and history endpoints)
- [x] VIII. Separation of Concerns: No business logic in UI - frontend only handles rendering, user input, and API calls
- [x] IX. Stateless AI Architecture: Server remains stateless, conversation context reconstructed from database per request
- [x] X. MCP-First AI Design: AI Agent (Part B) already implements MCP-only interaction - no changes needed
- [x] XI. Tool-Driven Intelligence: AI actions route through MCP tools (Part B implementation) - integration maintains this
- [x] XII. Safety & Determinism: AI responses auditable via stored messages and tool call logs (Part B feature)
- [x] Web UX Standards: Responsive design, loading states, error handling, visual feedback all specified

**Result**: ✅ All constitution principles satisfied. No violations. This is pure integration work following established patterns.

## Project Structure

### Documentation (this feature)

```text
specs/Phase-III-todo-ai-chatbot/Part-C-chat-ui-integration/
├── spec.md              # Feature specification (complete)
├── plan.md              # This file
├── research.md          # Phase 0 output (to be generated)
├── data-model.md        # Phase 1 output (to be generated)
├── quickstart.md        # Phase 1 output (to be generated)
├── contracts/           # Phase 1 output (to be generated)
│   ├── chat-endpoint.json
│   └── conversation-history-endpoint.json
├── checklists/
│   └── requirements.md  # Specification quality checklist (complete)
└── tasks.md             # Phase 2 output (generated by /sp.tasks command)
```

### Source Code (repository root)

```text
Phase-3-todo-ai-chatbot/
├── backend/
│   ├── src/
│   │   ├── models/
│   │   │   ├── conversation.py      # NEW: Conversation model
│   │   │   └── message.py           # NEW: Message model
│   │   ├── services/
│   │   │   └── conversation_service.py  # NEW: Conversation management
│   │   ├── api/
│   │   │   └── routes/
│   │   │       └── chat.py          # MODIFY: Add chat & history endpoints
│   │   └── schemas/
│   │       └── chat_schemas.py      # NEW: Request/response schemas
│   └── tests/
│       ├── test_conversation_service.py  # NEW: Service tests
│       └── test_chat_endpoints.py        # NEW: API tests
│
└── frontend/
    └── src/
        ├── app/
        │   └── chat/
        │       └── page.tsx         # NEW: Chat page component
        ├── components/
        │   ├── ChatInterface.tsx    # NEW: Main chat UI component
        │   ├── MessageList.tsx      # NEW: Message display component
        │   └── MessageInput.tsx     # NEW: Message input component
        ├── services/
        │   └── chatService.ts       # NEW: API client for chat endpoints
        └── hooks/
            └── useChat.ts           # NEW: Chat state management hook
```

**Structure Decision**: Following existing Phase 3 monorepo structure with backend/ and frontend/ directories. New code integrates into existing structure without creating additional projects or layers. Chat UI components follow Next.js 16+ App Router conventions.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

No violations detected. This section is not applicable.

---

## Phase 0: Research & Technology Validation

### Research Questions

The following areas require investigation to ensure successful integration:

1. **OpenAI ChatKit Integration with Next.js**
   - How to integrate ChatKit components with Next.js 16+ App Router
   - Component API and customization options
   - State management patterns for chat interfaces
   - TypeScript type definitions and usage

2. **JWT Token Management in Chat Context**
   - How to pass JWT tokens from Better Auth to chat API requests
   - Token refresh handling during long chat sessions
   - Error handling for expired tokens in chat context
   - Client-side token storage best practices

3. **Conversation Persistence Patterns**
   - Database schema design for conversations and messages
   - Efficient querying for conversation history (pagination, ordering)
   - Indexing strategy for performance
   - Handling concurrent message inserts

4. **Real-time UI Updates**
   - Optimistic UI updates for sent messages
   - Loading states during AI processing
   - Error recovery and retry mechanisms
   - Auto-scroll behavior for new messages

5. **Chat-Specific Error Handling**
   - User-friendly error messages for chat context
   - Network error recovery patterns
   - Rate limiting feedback
   - Authentication error handling in chat flow

### Research Tasks

Each research question will be investigated and documented in `research.md` with:
- **Decision**: What approach/technology was chosen
- **Rationale**: Why this choice was made
- **Alternatives Considered**: What other options were evaluated
- **Implementation Notes**: Key details for implementation phase

### Research Output

All findings will be consolidated in `research.md` following the template structure.

---

## Phase 1: Design & Contracts

### 1.1 Data Model Design

**Objective**: Define database schema for conversations and messages.

**Entities to Model**:

1. **Conversation**
   - Fields: id (UUID), user_id (FK to users), created_at, updated_at
   - Relationships: One-to-many with Message
   - Indexes: user_id for efficient user conversation queries
   - Validation: user_id must reference existing user

2. **Message**
   - Fields: id (UUID), conversation_id (FK), role (enum: user/assistant), content (text), timestamp, metadata (JSON, optional)
   - Relationships: Many-to-one with Conversation
   - Indexes: conversation_id + timestamp for efficient history retrieval
   - Validation: role must be 'user' or 'assistant', content max 1000 chars for user messages

**Output**: `data-model.md` with entity definitions, relationships, and validation rules.

### 1.2 API Contract Generation

**Objective**: Define OpenAPI specifications for new endpoints.

**Endpoints to Specify**:

1. **POST /api/{user_id}/chat**
   - Request: message (string), conversation_id (optional UUID), requires_confirmation (optional boolean)
   - Response: success, response, conversation_id, message_id, tool_calls, requires_confirmation, timestamp
   - Error responses: AUTH_FAILED, UNAUTHORIZED, RATE_LIMIT, INVALID_INPUT, AI_ERROR, DATABASE_ERROR
   - Authentication: JWT token required in Authorization header

2. **GET /api/{user_id}/conversations/{conversation_id}/messages**
   - Query params: limit (default 50, max 100), offset (default 0)
   - Response: success, messages array, total_count, has_more
   - Error responses: AUTH_FAILED, UNAUTHORIZED, NOT_FOUND, DATABASE_ERROR
   - Authentication: JWT token required in Authorization header

**Output**:
- `contracts/chat-endpoint.json` (OpenAPI 3.0 specification)
- `contracts/conversation-history-endpoint.json` (OpenAPI 3.0 specification)

### 1.3 Quickstart Guide

**Objective**: Document how to run and test the integrated chat system.

**Sections**:
1. Prerequisites (Parts A and B must be running)
2. Database migration (add conversation and message tables)
3. Environment variables (if any new ones needed)
4. Starting the system (backend + frontend)
5. Testing the chat interface (manual test scenarios)
6. Troubleshooting common issues

**Output**: `quickstart.md` with step-by-step instructions.

### 1.4 Agent Context Update

**Objective**: Update agent-specific context files with new technologies and patterns.

**Action**: Run `.specify/scripts/powershell/update-agent-context.ps1 -AgentType claude` (or bash equivalent if PowerShell unavailable)

**New Context to Add**:
- OpenAI ChatKit usage patterns
- Chat-specific API endpoints
- Conversation/message data models
- JWT token handling in chat context

**Output**: Updated agent context file with new information preserved between markers.

---

## Phase 2: Task Generation

**Note**: This phase is executed by the `/sp.tasks` command, NOT by `/sp.plan`.

The `/sp.tasks` command will:
1. Read this plan.md and all Phase 1 artifacts
2. Generate a detailed, dependency-ordered task list in `tasks.md`
3. Each task will include:
   - Clear description and acceptance criteria
   - Dependencies on other tasks
   - Test cases to verify completion
   - Estimated complexity

**Expected Task Categories**:
1. Database schema and migrations
2. Backend models and services
3. Backend API endpoints
4. Frontend components and pages
5. Frontend API client and hooks
6. Integration testing
7. End-to-end testing
8. Documentation updates

---

## Implementation Phases (Post-Planning)

### Phase 3: Red (Test-First)
- Write failing tests for all new functionality
- Tests cover: models, services, API endpoints, UI components
- Integration tests for end-to-end chat flow

### Phase 4: Green (Implementation)
- Implement database models (Conversation, Message)
- Implement conversation service
- Implement chat and history API endpoints
- Implement frontend chat components
- Implement API client and state management
- All tests pass

### Phase 5: Refactor (Optimization)
- Code review and cleanup
- Performance optimization (query efficiency, UI responsiveness)
- Error handling improvements
- Documentation updates

### Phase 6: Integration Verification
- End-to-end testing with real AI Agent
- Multi-user testing
- Performance testing (concurrent sessions)
- Security testing (authentication, authorization)
- Browser compatibility testing

---

## Risk Assessment

### Technical Risks

1. **OpenAI ChatKit Compatibility**
   - Risk: ChatKit may not integrate smoothly with Next.js 16+ App Router
   - Mitigation: Research phase will validate integration, fallback to custom chat UI if needed
   - Impact: Medium (could require custom component development)

2. **Performance Under Load**
   - Risk: 100 concurrent sessions may strain database or AI Agent
   - Mitigation: Implement connection pooling, query optimization, load testing
   - Impact: Medium (could require infrastructure scaling)

3. **Token Expiration During Chat**
   - Risk: JWT tokens expiring mid-conversation disrupts user experience
   - Mitigation: Implement token refresh logic, graceful error handling
   - Impact: Low (Better Auth handles refresh, need proper error UX)

### Integration Risks

1. **AI Agent Response Time**
   - Risk: AI Agent may exceed 3-second target response time
   - Mitigation: Already implemented in Part B with retry logic, monitor and optimize
   - Impact: Low (Part B already handles this)

2. **Database Schema Changes**
   - Risk: Adding new tables may require migration coordination
   - Mitigation: Use SQLModel migrations, test thoroughly in dev environment
   - Impact: Low (standard migration process)

### User Experience Risks

1. **Chat Interface Usability**
   - Risk: Users may find chat interface confusing or difficult to use
   - Mitigation: Follow established chat UI patterns, user testing, clear error messages
   - Impact: Medium (affects adoption)

2. **Error Message Clarity**
   - Risk: Technical errors may confuse non-technical users
   - Mitigation: Implement user-friendly error messages as specified
   - Impact: Low (spec already defines error handling)

---

## Success Metrics

### Functional Completeness
- [ ] All 15 functional requirements implemented and tested
- [ ] All 5 user stories have passing acceptance tests
- [ ] All edge cases handled gracefully

### Performance Targets
- [ ] Chat endpoint response time <3s (95th percentile)
- [ ] Conversation history load <2s
- [ ] 100 concurrent sessions supported
- [ ] Database queries <500ms

### Quality Metrics
- [ ] 90%+ test coverage for new code
- [ ] Zero critical security vulnerabilities
- [ ] All constitution principles maintained
- [ ] Code review approved

### User Experience
- [ ] Chat interface responsive on mobile and desktop
- [ ] Loading states clear and informative
- [ ] Error messages actionable and user-friendly
- [ ] 90%+ natural language command success rate

---

## Dependencies

### External Dependencies
- Part A (MCP Server): COMPLETE ✅
- Part B (AI Agent): COMPLETE ✅
- Better Auth: CONFIGURED ✅
- Neon PostgreSQL: AVAILABLE ✅
- Next.js Frontend: EXISTS ✅

### Internal Dependencies
- Database migration for new tables (Conversation, Message)
- OpenAI ChatKit library installation
- API endpoint registration in FastAPI app
- Frontend routing for chat page

### Blocking Issues
None identified. All prerequisites are met.

---

## Next Steps

1. **Complete Phase 0**: Generate `research.md` by investigating the 5 research questions
2. **Complete Phase 1**: Generate `data-model.md`, `contracts/`, and `quickstart.md`
3. **Run `/sp.tasks`**: Generate detailed task list in `tasks.md`
4. **Run `/sp.implement`**: Execute tasks in dependency order
5. **Verify Integration**: Run end-to-end tests and validate all acceptance criteria

---

## Notes

- This is an integration feature - no architectural changes to existing systems
- All new code follows established patterns from Parts A and B
- Constitution compliance maintained throughout
- Focus on user experience and error handling per specification
- Performance targets are realistic based on existing Part B performance
